{"version":3,"file":"/Users/taojiang/Documents/work/redux_study/redux_/src/createStore.ts","sources":["/Users/taojiang/Documents/work/redux_study/redux_/src/createStore.ts"],"names":[],"mappings":";;AA0BA;;;;;;;GAOG;AAEH,SAAS,WAAW,CAAC,OAAgB,EAAE,SAAe;IACpD;;OAEG;IACH,IAAI,KAAK,GAAG,SAAS,CAAC;IAEtB;;OAEG;IACH,IAAI,SAAS,GAAe,EAAE,CAAC;IAE/B;;;OAGG;IACH,SAAS,SAAS,CAAC,QAAkB;QACnC,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAA;QACxB,OAAO,SAAS,WAAW;YACzB,IAAI,GAAG,GAAW,SAAS,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;YAC9C,IAAI,GAAG,GAAG,CAAC,CAAC;gBAAE,SAAS,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;QACtC,CAAC,CAAA;IACH,CAAC;IAAA,CAAC;IAEF;;;OAGG;IACH,SAAS,QAAQ,CAAC,MAAiB;QACjC,IAAI,QAAQ,GAAG,OAAO,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;QACtC,KAAK,GAAG,QAAQ,CAAC;QACjB,IAAI,GAAG,GAAG,SAAS,CAAC,MAAM,CAAC;QAC3B,sBAAsB;QACtB,OAAO,EAAE,GAAG,GAAG,CAAC,CAAC;YAAE,SAAS,CAAC,GAAG,CAAC,EAAE,CAAC;IACtC,CAAC;IAAA,CAAC;IAEF,SAAS,QAAQ;QACf,OAAO,KAAK,CAAC;IACf,CAAC;IAED,8DAA8D;IAC9D,QAAQ,CAAC,EAAE,IAAI,EAAE,MAAM,CAAC,GAAG,CAAC,aAAa,CAAC,EAAE,CAAC,CAAA;IAE7C,OAAO,EAAE,QAAQ,EAAE,SAAS,EAAE,QAAQ,EAAE,CAAA;AAC1C,CAAC;AAEc,kCAAW","sourcesContent":["\n\n\n/**\n * action\n */\ntype AnyAction = { type: string | number | Symbol, data?: any }\n\n/**\n * 每个reducer 都会返回一个state的clone，来代替新的 state\n */\ntype Reducer = (state: any, action: AnyAction) => any;\n\n/** 取消订阅 */\ntype unsbuscribe = () => void;\n\n\n/**\n * Store 对象\n */\ninterface Store {\n  subscribe: (listener: Function) => unsbuscribe;\n  dispatch: (action: AnyAction) => void;\n  getState: () => any;\n}\n\n/**\n * 面向函数是思维\n *  value 即是 state\n *  dispatch -> map\n *  \n * 创建一个store容器,基于发布订模式来处理，dispatch派发出的action处理对应的reducer\n * 注意:Action 唯一\n */\n\nfunction createStore(reducer: Reducer, initState?: any): Store {\n  /**\n   *  状态管理\n   */\n  let state = initState;\n\n  /**\n   * 订阅者的列表 \n   */\n  let listeners: Function[] = [];\n\n  /**\n   * 观察消息订阅\n   * @param listener \n   */\n  function subscribe(listener: Function) {\n    listeners.push(listener)\n    return function unsbuscribe() {\n      let del: number = listeners.indexOf(listener);\n      if (del > -1) listeners.splice(del);\n    }\n  };\n\n  /**\n   * 派发一个 action 对象\n   * @param action \n   */\n  function dispatch(action: AnyAction) {\n    let newState = reducer(state, action);\n    state = newState;\n    let len = listeners.length;\n    //reducer 处理完了之后，回调订阅者\n    while (--len > -1) listeners[len]();\n  };\n\n  function getState(): any {\n    return state;\n  }\n  \n  /**在createStore 被调用的时候先初始化所有的reducer，这个的reducer是穿透的每个都会执行到位 */\n  dispatch({ type: Symbol.for('initReuders') })\n\n  return { dispatch, subscribe, getState }\n}\n\nexport {Store, createStore, Reducer, AnyAction, unsbuscribe }"]}